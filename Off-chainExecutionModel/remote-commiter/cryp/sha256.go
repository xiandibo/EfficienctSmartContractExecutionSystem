package cryp

import (
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"fmt"
)

//模拟对消息的加密解密的时间开销，实际并没真正对确切的数据进行签名和认证


var PrivateKey = []byte{45,45,45,45,45,66,69,71,73,78,32,82,83,65,32,80,82,73,86,65,84,69,32,75,69,89,45,45,45,45,45,10,77,73,73,67,88,65,73,66,65,65,75,66,103,81,67,116,73,83,55,115,97,88,105,100,84,68,71,68,51,82,97,68,104,68,80,99,76,77,90,65,57,114,100,82,51,117,67,87,69,99,57,77,84,69,82,66,110,98,106,70,67,119,90,85,10,106,81,86,54,51,77,99,101,52,117,71,100,85,68,121,103,74,49,118,103,67,49,69,100,85,119,86,81,56,49,109,88,76,109,90,80,118,103,101,75,75,56,119,110,86,112,72,57,56,86,114,77,47,119,73,70,100,104,117,43,110,117,54,100,10,56,107,97,83,77,51,103,69,113,83,85,78,119,80,114,105,56,69,55,120,105,108,86,48,78,82,111,121,97,98,100,84,88,57,106,90,89,117,85,87,56,118,51,86,69,102,89,53,56,68,67,86,56,86,99,78,98,81,73,68,65,81,65,66,10,65,111,71,65,99,55,47,68,120,51,117,99,107,69,51,111,114,79,105,98,114,77,73,117,105,102,51,70,98,112,109,69,90,116,66,69,66,120,70,82,76,119,109,117,101,78,65,105,81,70,114,109,109,74,68,81,73,82,121,75,90,68,80,55,10,56,49,107,53,114,122,109,104,83,50,70,70,107,102,49,51,105,71,43,113,98,108,69,118,82,80,101,81,52,99,69,54,47,47,71,88,73,82,103,109,99,111,116,122,65,80,88,52,81,103,119,110,101,68,115,118,84,118,49,52,55,110,43,88,10,57,65,73,65,118,66,57,74,66,68,114,47,77,89,87,112,121,57,81,73,120,51,53,108,105,77,65,74,65,76,71,76,98,105,118,66,99,52,50,104,57,67,108,57,51,71,69,67,81,81,68,79,105,74,102,47,73,54,65,71,56,113,122,118,10,79,81,117,66,115,105,89,101,83,78,68,71,89,108,51,89,43,77,111,114,90,90,118,100,66,56,52,122,76,47,49,85,47,54,109,70,122,85,89,53,111,114,112,71,85,115,84,57,101,80,110,112,69,71,68,108,99,81,47,83,99,98,84,111,10,103,88,112,98,43,103,85,80,65,107,69,65,49,112,104,49,100,82,81,50,101,66,114,54,75,118,120,119,50,97,43,50,87,72,105,103,73,118,57,78,66,57,78,79,116,102,55,78,80,90,66,66,115,85,109,51,83,85,118,78,84,75,73,89,10,76,68,75,48,90,109,82,120,76,81,57,55,121,113,54,48,51,112,107,81,112,86,53,75,74,69,51,85,86,73,87,100,119,119,74,65,98,122,106,50,67,99,116,73,109,90,86,69,100,103,117,86,87,56,72,120,98,121,117,116,97,114,104,56,10,97,54,85,72,85,114,109,69,90,49,75,86,119,57,69,98,76,120,81,68,87,102,65,67,50,110,84,56,116,88,82,76,97,50,107,106,120,70,81,121,113,106,122,112,49,86,50,119,109,43,108,109,87,72,80,98,70,119,74,65,98,74,57,78,10,84,81,56,72,74,122,74,89,107,79,117,111,51,55,100,101,99,70,102,87,106,119,66,49,97,70,71,103,86,79,84,57,49,72,121,120,107,43,68,66,89,116,116,52,116,113,75,82,52,56,86,105,112,84,87,81,83,65,79,47,89,71,43,103,10,89,57,66,77,113,98,103,90,104,86,106,84,56,108,105,84,54,119,74,66,65,76,99,110,67,118,52,75,90,73,107,70,90,56,115,82,47,48,66,74,50,72,79,83,75,99,76,68,68,80,83,120,53,74,76,77,88,116,51,121,121,79,107,86,10,54,78,105,118,98,120,49,103,67,48,109,115,76,114,116,119,100,77,80,99,69,56,73,103,57,47,97,110,122,51,50,57,113,110,122,54,98,99,104,80,71,71,103,61,10,45,45,45,45,45,69,78,68,32,82,83,65,32,80,82,73,86,65,84,69,32,75,69,89,45,45,45,45,45,10}
var PublicKey = []byte{45,45,45,45,45,66,69,71,73,78,32,80,85,66,76,73,67,32,75,69,89,45,45,45,45,45,10,77,73,71,102,77,65,48,71,67,83,113,71,83,73,98,51,68,81,69,66,65,81,85,65,65,52,71,78,65,68,67,66,105,81,75,66,103,81,67,116,73,83,55,115,97,88,105,100,84,68,71,68,51,82,97,68,104,68,80,99,76,77,90,65,10,57,114,100,82,51,117,67,87,69,99,57,77,84,69,82,66,110,98,106,70,67,119,90,85,106,81,86,54,51,77,99,101,52,117,71,100,85,68,121,103,74,49,118,103,67,49,69,100,85,119,86,81,56,49,109,88,76,109,90,80,118,103,101,75,10,75,56,119,110,86,112,72,57,56,86,114,77,47,119,73,70,100,104,117,43,110,117,54,100,56,107,97,83,77,51,103,69,113,83,85,78,119,80,114,105,56,69,55,120,105,108,86,48,78,82,111,121,97,98,100,84,88,57,106,90,89,117,85,87,10,56,118,51,86,69,102,89,53,56,68,67,86,56,86,99,78,98,81,73,68,65,81,65,66,10,45,45,45,45,45,69,78,68,32,80,85,66,76,73,67,32,75,69,89,45,45,45,45,45,10}

var data = "This is the hypothetical data for communication between nodes."
var signed_Data = []byte{35,96,97,58,18,109,192,94,13,246,120,226,231,172,208,244,247,199,43,222,194,57,101,253,225,104,23,210,195,161,255,248,53,17,45,229,235,79,121,244,67,121,37,16,82,31,56,197,74,148,246,63,84,165,225,151,64,136,178,154,73,113,64,73,13,146,65,171,241,23,186,40,136,25,95,110,98,94,25,82,119,234,39,122,180,72,176,104,28,192,25,181,203,203,82,49,192,170,49,63,167,4,96,60,249,223,237,171,47,41,208,145,110,100,149,80,173,165,204,227,192,229,204,164,118,21,22,134}

// 签名和验证接口
// 固定数据内容，仅作为模拟加密算法的时间开销
func Sign()  {
	signData := RsaSignWithSha256([]byte(data), PrivateKey)
	signed_Data = signData
	//fmt.Println(signData)
}

func Validate()  {
	if RsaVerySignWithSha256([]byte(data), signed_Data, PublicKey) {
		//fmt.Println("签名信息验证成功，确定是正确私钥签名！！")
	}
}


//func main() {
//	//rsa 密钥文件产生
//	fmt.Println("-------------------------------获取RSA公私钥-----------------------------------------")
//	prvKey, pubKey := GenRsaKey()
//	fmt.Println(prvKey)
//	fmt.Println(pubKey)
//
//	var s string = string(pubKey)
//	pub := []byte(s)
//	fmt.Println(pub)
//
//	fmt.Println("-------------------------------进行签名与验证操作-----------------------------------------")
//	var data = "卧了个槽，这么神奇的吗？？！！！  ԅ(¯﹃¯ԅ) ！！！！！！）"
//	fmt.Println("对消息进行签名操作...")
//	signData := RsaSignWithSha256([]byte(data), prvKey)
//	fmt.Println("消息的签名信息： ", hex.EncodeToString(signData))
//	fmt.Println("\n对签名信息进行验证...")
//	if RsaVerySignWithSha256([]byte(data), signData, pubKey) {
//		fmt.Println("签名信息验证成功，确定是正确私钥签名！！")
//	}
//
//	fmt.Println("-------------------------------进行加密解密操作-----------------------------------------")
//	ciphertext := RsaEncrypt([]byte(data), pubKey)
//	fmt.Println("公钥加密后的数据：", hex.EncodeToString(ciphertext))
//	sourceData := RsaDecrypt(ciphertext, prvKey)
//	fmt.Println("私钥解密后的数据：", string(sourceData))
//}

//RSA公钥私钥产生
func GenRsaKey() (prvkey, pubkey []byte) {
	// 生成私钥文件
	privateKey, err := rsa.GenerateKey(rand.Reader, 1024)
	if err != nil {
		panic(err)
	}
	derStream := x509.MarshalPKCS1PrivateKey(privateKey)
	block := &pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: derStream,
	}
	prvkey = pem.EncodeToMemory(block)
	publicKey := &privateKey.PublicKey
	derPkix, err := x509.MarshalPKIXPublicKey(publicKey)
	if err != nil {
		panic(err)
	}
	block = &pem.Block{
		Type:  "PUBLIC KEY",
		Bytes: derPkix,
	}
	pubkey = pem.EncodeToMemory(block)
	return
}

//签名
func RsaSignWithSha256(data []byte, keyBytes []byte) []byte {
	h := sha256.New()
	h.Write(data)
	hashed := h.Sum(nil)
	block, _ := pem.Decode(keyBytes)
	if block == nil {
		panic(errors.New("private key error"))
	}
	privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		fmt.Println("ParsePKCS8PrivateKey err", err)
		panic(err)
	}

	signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hashed)
	if err != nil {
		fmt.Printf("Error from signing: %s\n", err)
		panic(err)
	}

	return signature
}

//验证
func RsaVerySignWithSha256(data, signData, keyBytes []byte) bool {
	block, _ := pem.Decode(keyBytes)
	if block == nil {
		panic(errors.New("public key error"))
	}
	pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		panic(err)
	}

	hashed := sha256.Sum256(data)
	err = rsa.VerifyPKCS1v15(pubKey.(*rsa.PublicKey), crypto.SHA256, hashed[:], signData)
	if err != nil {
		panic(err)
	}
	return true
}

// 公钥加密
func RsaEncrypt(data, keyBytes []byte) []byte {
	//解密pem格式的公钥
	block, _ := pem.Decode(keyBytes)
	if block == nil {
		panic(errors.New("public key error"))
	}
	// 解析公钥
	pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		panic(err)
	}
	// 类型断言
	pub := pubInterface.(*rsa.PublicKey)
	//加密
	ciphertext, err := rsa.EncryptPKCS1v15(rand.Reader, pub, data)
	if err != nil {
		panic(err)
	}
	return ciphertext
}

// 私钥解密
func RsaDecrypt(ciphertext, keyBytes []byte) []byte {
	//获取私钥
	block, _ := pem.Decode(keyBytes)
	if block == nil {
		panic(errors.New("private key error!"))
	}
	//解析PKCS1格式的私钥
	priv, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		panic(err)
	}
	// 解密
	data, err := rsa.DecryptPKCS1v15(rand.Reader, priv, ciphertext)
	if err != nil {
		panic(err)
	}
	return data
}

